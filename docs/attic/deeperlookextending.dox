/** \page deeperlookextending A Deeper Look into Extending SST/macro

The tutorials directory of the SST/macro distribution contains 
a set of simple code examples that serve as a starting point
for users to develop simulation drivers and skeleton applications
in the SST/macro environment.  

A pre-existing C++ driver sets up the
simulation environment and runs the application.  As seen in
the section \ref extending, most SST/macro users will generally not
need to write their own <tt>main</tt> routine. However, to illustrate important
classes, we examine the program setup in more detail.

SST/macro employs a custom runtime that maps strings to C++ objects. This provides an "interpreter",
allowing dynamic object construction based on the input file. This runtime info is maintained for
most objects that require polymorphism. Objects can then be constructed by "factory" objects
from string names.

For application objects, e.g., when the simulator launches, static initialization builds
the runtime info for each class.  This is managed in the code by using the <tt>SpktRegisterApp</tt> macro. 
We can glance briefly at the code generated by the <tt>SpktRegisterApp</tt> macro.  
\dontinclude sstmac/common/factories/app_factory.h
\skipline SSTAppFactory_desc(const
The constructor registers the descriptor with the runtime build system.
\skipline name
\skipline register
When the SST/macro simulation begins, a "template" application is built, potentially
configurable with input file parameters.
\skip build
\until }
Each instance of an application gets assigned a software id, which is just a composite of the task
id and application id.  In the simplest cases, the application id is the same on all nodes and
is just zero.  The task id will usually correspond to the node number or MPI rank.

\dontinclude sstmac/main/sstmac.cc
Returning to <tt>main</tt>, we construct a parameter object that will be
used to configure the simulation.
\skipline file_parameters::construct
The header library sprockit::refcount_ptr is used by SST/macro
to handle memory management. Memory-managed classes typedef the intrusive
pointer type as <tt>ptr</tt>, as in <tt>file_parameters::ptr</tt>.


The main routine calls the run method to launch the simulation.
\skipline run
The parameter object is passed as the first argument.  A <tt>timestamp</tt> object is passed as
the second argument specifying how long the simulator should run.  A time of -1 indicates the simulation
should simply run until done. The parameter sets a debug printing flag, and is generally set to <tt>false</tt>. 

The run method is defined in the included driver.h file.
\dontinclude sstmac/backends/native/driver.h
\skip eventmanager
\until run

All activity over the network depends on the chosen interconnect model.
The interconnect model provides the coarse grained-modeling
for network traffic.  Several concrete interconnect classes are 
provided by SST/macro. See the descendants of sstmac::hw::interconnect 
for documentation.  In this case sstmac::hw::circuit is used, and is generated
by the <tt>construct_circuit</tt> method call.
\skipline interconnect
The method reads the network parameters specified previously in the <tt>main</tt> routine.
After we enter a try block to catch any exceptions thrown, we construct the manager
\skipline manager::construct
and then configure it for the constructed circuit interconnect
\skipline set_interconnect

One the network interconnect is created, the individual nodes can be created. 
\skipline add_nodes
When the nodes are added, they are linked to the network via a network interface controller 
that transmits data from the node into the network 
and vice versa.  The node also gets assigned an operating system and abstract machine interface (AMI).

Finally, we are ready to run the simulation.
\skipline runtime
The manager then runs until the time specified and returns the total runtime.
 
*/

